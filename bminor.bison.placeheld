%{
#include <stdio.h>
#define YYSTYPE int

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );
%}

%token TOKEN_EOF
<keywords_placeholder>
<literal_tokens_placeholder>
%token IDENT
%token STR_LIT
%token INT_LIT
%token CHAR_LIT
%token INTERNAL_ERR
%token SCAN_ERR


%%

program : maybe_decls { return 0; }
        ;

/* END PROGRAM ================================= BEGIN DECLARATIONS */
decl : IDENT COLON type S_COL
     | IDENT COLON type ASGN expr S_COL
     | IDENT COLON type ASGN L_BRC maybe_stmts R_BRC
     ;

type : INTEGER
     | STRING
     | CHAR
     | BOOLEAN
     | VOID
     | ARRAY L_BRK R_BRK type        /* infer length from initializer */
     | ARRAY L_BRK expr R_BRK type   /* we'll catch whether this expression is of a type for which we can generate code later on in the pipeline */

     | FUNCTION type L_PAR maybe_param_list R_PAR
     ;

maybe_param_list : /* empty */
                 | param_list
                 ;

param_list : IDENT COLON type 
           | IDENT COLON type COMMA param_list
           ;

maybe_decls : /* empty*/
            | decl maybe_decls
            ;

/* END DECLARATIONS ============================ BEGIN STATEMENTS */

/*
if and for statements need to be considered separately because they both end with statements
    - if-else is obviously vulnerable to dangling else ambiguities
    - once if-else solved, we need to be careful of for statements too. They end with a statement, meaning if we included them in a 'stmt' nonterminal and did nothing else, then it is possible that a for loop appears as the "then" body of an if-else statement and its 'stmt' might be a dangling if: then, we would have ambiguities again.

    - Note: drew inspriation from in-class dangling-if discussion and Java's solution (https://docs.oracle.com/javase/specs/jls/se9/html/jls-14.html). A statement can be anything we would think it would be. However, the "then" clause of an if-then statement can only contain a statement known not to end with a dangling if: this ensures that the "else" must match this "if" unambiguously. The statements known for sure not to end with a dangling if are those which do not end with another statement and those which do end with another statement, but that statement is known not to end with a dangling else.
*/

stmt : non_right_recursive_stmt
     | if_stmt
     | for_stmt
     | decl
     ;


non_right_recursive_stmt : expr S_COL
                         | L_BRC maybe_stmts R_BRC
                         | PRINT maybe_expr_comma_list S_COL
                         | RETURN maybe_expr S_COL
                         ;


if_stmt : IF L_PAR expr R_PAR non_dangling_stmt ELSE stmt
        | IF L_PAR expr R_PAR stmt 
        ;

non_dangling_if : IF L_PAR expr R_PAR non_dangling_stmt ELSE non_dangling_stmt ;


for_stmt : FOR L_PAR maybe_expr S_COL maybe_expr S_COL maybe_expr R_PAR stmt ;

non_dangling_for : FOR L_PAR maybe_expr S_COL maybe_expr S_COL maybe_expr R_PAR non_dangling_stmt ;


/* statement not ending with a dangling if. The only place we use this in a rule besides to define other non_dangling structures is the if-else "then" body */
/* note that a non_dangling_stmt cannot reduce to a stmt directly, so there is no ambiguity here */
non_dangling_stmt : non_right_recursive_stmt
                  | non_dangling_for
                  | non_dangling_if
                  ;


maybe_stmts : /* empty */
            | stmt maybe_stmts
            ;

/* END STATEMENTS ============================ BEGIN EXPRESSIONS */

/* expression: can be treated as a single value */
expr : expr10
     ;

/* assignment: = */
expr10: expr9 ASGN expr10
      | expr9
      ;

/* logical or: || (lower precedence bc add in bool alg */
expr9 : expr9 OR expr8
      | expr8
      ;
/* logical and: && (higher precedence bc mult in bool alg */
expr8 : expr8 AND expr7
      | expr7
      ;

/* comparisons: < <= > >= == != */
expr7 : expr7 LT expr6
      | expr7 LT_EQ expr6
      | expr7 GT expr6
      | expr7 GT_EQ expr6
      | expr7 EQ expr6
      | expr7 NOT_EQ expr6
      | expr6
      ;

/* binary add/sub: + - */
expr6 : expr6 PLUS expr5
      | expr6 MINUS expr5
      | expr5
      ;

/* mult/div/mod: * / % */
expr5 : expr5 STAR expr4
      | expr5 SLASH expr4
      | expr5 PRCT expr4
      | expr4
      ;

/* exponentiaion: ^ */
expr4 : expr4 CARET expr3
      | expr3
      ;

/* unary operators: + - ! */
expr3 : PLUS expr3
      | MINUS expr3
      | NOT expr3
      | expr2
      ;

/* unary postfix decrement/increment */
expr2 : expr2 DEC
      | expr2 INC
      | expr1
      ;

/* grouping: () [] f() */
expr1 : L_PAR expr R_PAR
      | expr1 L_BRK expr R_BRK
      | func_call
      | atom
      ;

/* atom: lowest form of expression */
atom : IDENT
     | STR_LIT
     | INT_LIT
     | CHAR_LIT
     | TRUE
     | FALSE
     | arr_lit /* should this be here or in decl? technically you can only have an array literal like this in a declaration, but I like the general idea of having an array literal that, when used, creates a temporary array for you to use in your expression */
     ;


/* function call: <function name>(<arg list>) */
func_call: IDENT L_PAR maybe_expr_comma_list R_PAR
         ;

/* array literal: {<value list>} - used to initialize arrays at declaration */
arr_lit : L_BRC expr_comma_list R_BRC
        ;

/* maybe comma separated list : comma list of empty */
maybe_expr_comma_list: /* empty */
                     | expr_comma_list
                     ;

/* comma list: arbirary number of values separated by commas */
expr_comma_list: expr
               | expr COMMA expr_comma_list
               ;

maybe_expr : /* empty */
            | expr
            ;

%%

int yyerror( char *str )
{
    printf("parse error: %s\n",str);
    return 0;
}
