%{
#include <stdio.h>
#define YYSTYPE int

extern char *yytext;
extern int yylex();
extern int yyerror( char *str );
%}

%token TOKEN_EOF
<keywords_placeholder>
<literal_tokens_placeholder>
%token IDENT
%token STR_LIT
%token INT_LIT
%token CHAR_LIT
%token INTERNAL_ERR
%token SCAN_ERR

%%

program : maybe_decls {{return 0;}}
        ;

maybe_decls : /* empty*/
            | decl maybe_decls
            ;

/* END PROGRAM ================================= BEGIN DECLARATIONS */
// here's an idea: leave semi-colon off declaration and allow decl = expr; and decl; as a statement
// problem: if we only want to allow decl's in our top level program, how to include/differentiate/have decls w/o having a statement
decl : IDENT COLON type S_COL
     | IDENT COLON type ASGN expr S_COL
     | IDENT COLON type ASGN L_BRC maybe_stmts R_BRC
     ;

type : INTEGER
     | STRING
     | CHAR
     | ARRAY L_BRK INT_LIT R_BRK type
/*   | ARRAY L_BRK expr R_BRK type   /* maybe in the future... */
     | FUNCTION return_type L_PAR maybe_param_list R_PAR
     ;

return_type : type | VOID ;

maybe_param_list : /* empty */
                 | param_list
                 ;

param_list : IDENT COLON type 
           | IDENT COLON type COMMA param_list
           ;


/* END DECLARATIONS ============================ BEGIN STATEMENTS */

/*
if and for statements need to be considered separately because they both end with statements
    - if-else is obviously vulnerable to dangling else ambiguities
    - once if-else solved, we need to be careful of for statements too. They end with a statement, meaning if we included them in a 'stmt' nonterminal and did nothing else, then it is possible that a for loop appears as the "then" body of an if-else statement and its 'stmt' might be a dangling if: then, we would have ambiguities again.

    - Java's solution (https://docs.oracle.com/javase/specs/jls/se9/html/jls-14.html), which inspired mine: a statement can be anything we would think it would be. However, the "then" clause of an if-then statement can only contain a statement known not to end with a dangling if: this ensures that the "else" must match this "if" unambiguously. The statements known for sure not to end with a dangling if are those which do not end with another statement and those which do end with another statement, but that statement is known not to end with a dangling else.
*/


/*
stmt : non_dangling_stmt
     | dangling_if
     | dangling_for
     ;
*/



stmt : non_right_recursive_stmt
     | if_stmt /* (if-else) */
  /* | IF L_PAR expr R_PAR stmt (only if) */
     | for_stmt
     ;


non_right_recursive_stmt : expr S_COL
                         | L_BRC maybe_stmts R_BRC
                         | PRINT maybe_expr_comma_list S_COL
                         | RETURN maybe_expr S_COL
                         ;

/*
dangling_if : IF L_PAR expr R_PAR stmt
        | IF L_PAR expr R_PAR non_dangling_stmt ELSE stmt
        ;
*/


if_stmt : IF L_PAR expr R_PAR non_dangling_stmt ELSE stmt
        /* | non_dangling_if */
        | IF L_PAR expr R_PAR stmt 
        ;


non_dangling_if : IF L_PAR expr R_PAR non_dangling_stmt ELSE non_dangling_stmt ;

/* note that a non_dangling_stmt cannot reduce to a stmt directly, so there is no ambiguity here */

/*
dangling_for : FOR L_PAR maybe_expr S_COL maybe_expr S_COL maybe_expr R_PAR stmt
             ;
*/


for_stmt : FOR L_PAR maybe_expr S_COL maybe_expr S_COL maybe_expr R_PAR stmt
         /* | non_dangling_for */
         ;



/* statement not ending with a dangling if - "NoShortIf". The only place we use this in a rule besides to define other non_dangling structures is the if-else "then" body */
non_dangling_stmt : non_right_recursive_stmt
                  | non_dangling_for
                  | non_dangling_if
                  ;

non_dangling_for : FOR L_PAR maybe_expr S_COL maybe_expr S_COL maybe_expr R_PAR non_dangling_stmt ;

maybe_stmts : /* empty */
            | stmt maybe_stmts
            ;

/* END STATEMENTS ============================ BEGIN EXPRESSIONS */

/* expression: can be treated as a single value */
expr : expr10
     ;

/* l-value: can be assigned to */
lvalue: IDENT L_BRK expr R_BRK
      | IDENT
      ;

/* assignment: = */
expr10: expr9 ASGN expr10
      | expr9 ASGN arr_lit
      | expr9
      ;

/* logical or: || (lower precedence bc add in bool alg */
expr9 : expr9 OR expr8
      | expr8
      ;
/* logical and: && (higher precedence bc mult in bool alg */
expr8 : expr8 AND expr7
      | expr7
      ;

/* comparisons: < <= > >= == != */
expr7 : expr7 LT expr6
      | expr7 LT_EQ expr6
      | expr7 GT expr6
      | expr7 GT_EQ expr6
      | expr7 EQ expr6
      | expr7 NOT_EQ expr6
      | expr6
      ;

/* binary add/sub: + - */
expr6 : expr6 PLUS expr5
      | expr6 MINUS expr5
      | expr5
      ;

/* mult/div/mod: * / % */
expr5 : expr5 STAR expr4
      | expr5 SLASH expr4
      | expr5 PRCT expr4
      | expr4
      ;

/* exponentiaion: ^ */
expr4 : expr4 CARET expr3
      | expr3
      ;

/* unary operators: + - ! */
expr3 : PLUS expr3
      | MINUS expr3
      | NOT expr3
      | expr2
      ;

/* unary postfix decrement/increment */
expr2 : expr2 DEC
      | expr2 INC
      | expr1
      ;

/* grouping: () [] f() */
expr1 : L_PAR expr R_PAR
      | L_BRK expr R_BRK
      | func_call
      | atom
      ;

/* atom: lowest form of expression */
atom: lvalue
    | STR_LIT
    | INT_LIT
    | CHAR_LIT
    ;

/*
expr2 : lvalue DEC
      | lvalue INC
      | DEC lvalue
      | INC lvalue
      | L_PAR expr R_PAR
      | func_call
      | atom
      ;
*/

/* function call: <function name>(<arg list>) */
func_call: IDENT L_PAR maybe_expr_comma_list R_PAR
         ;

/* array literal: {<value list>} - used to initialize arrays at declaration */
arr_lit : IDENT L_BRC expr_comma_list R_BRC
        ;

/* maybe comma separated list : comma list of empty */
maybe_expr_comma_list: /* empty */
                     | expr_comma_list
                     ;

/* comma list: arbirary number of values separated by commas */
expr_comma_list: expr
               | expr COMMA expr_comma_list
               ;

maybe_expr : /* empty */
            | expr
            ;

%%

int yyerror( char *str )
{
    printf("parse error: %s\n",str);
    return 0;
}
